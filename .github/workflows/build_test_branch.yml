name: Test Build CSVGenerator

on:
  push:
    branches: [ test ]
  pull_request:
    branches: [ test ]
  workflow_dispatch:

jobs:
  build-and-publish:
    runs-on: windows-latest
    
    defaults:
      run:
        shell: pwsh

    steps:
    - name: Checkout CSVGenerator (this repository)
      uses: actions/checkout@v4
      with:
        path: CSVGenerator # Checks out this repo into GITHUB_WORKSPACE/CSVGenerator

    - name: Checkout Common library
      uses: actions/checkout@v4
      with:
        repository: DarkPhilosophy/Common
        path: Common # Checks out Common repo into GITHUB_WORKSPACE/Common
        ref: test
        
    - name: Setup .NET SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x
        
    - name: Install .NET Framework 4.8 Developer Pack
      run: |
        choco install netfx-4.8-devpack -y --no-progress
        if ($LASTEXITCODE -ne 0) {
          Write-Error "Choco install failed for netfx-4.8-devpack"
          exit 1
        }

    - name: Temporarily update TargetFrameworks in project files for CI
      env:
        CI_WORKSPACE: ${{ github.workspace }} 
      run: |
        Write-Output "Script starting. Value of CI_WORKSPACE from step env: '$($env:CI_WORKSPACE)'"
        Write-Output "Script starting. Value of GITHUB_WORKSPACE from direct env access: '$($env:GITHUB_WORKSPACE)'"

        $baseWorkspacePath = $env:GITHUB_WORKSPACE
        if ([string]::IsNullOrWhiteSpace($baseWorkspacePath)) {
            Write-Warning "Direct $env:GITHUB_WORKSPACE was empty or null, trying $env:CI_WORKSPACE from step env."
            $baseWorkspacePath = $env:CI_WORKSPACE
        }

        if ([string]::IsNullOrWhiteSpace($baseWorkspacePath)) {
            Write-Error "Base workspace path is empty or null. Aborting."
            exit 1
        }
        Write-Output "Using base workspace path: '$baseWorkspacePath'"

        # These paths now correctly point to the roots of each checkout
        $csvGeneratorCheckoutPath = Join-Path $baseWorkspacePath "CSVGenerator" 
        $commonCheckoutPath = Join-Path $baseWorkspacePath "Common"          

        Write-Output "Calculated csvGeneratorCheckoutPath: '$csvGeneratorCheckoutPath'"
        Write-Output "Calculated commonCheckoutPath: '$commonCheckoutPath'"
        
        $projectRoots = @(
            $csvGeneratorCheckoutPath,
            $commonCheckoutPath
        )
        
        $tfmToReplace = 'net10.0-windows'
        $tfmReplacement = 'net9.0-windows'
        $escapedTfmToReplace = [regex]::Escape($tfmToReplace) # Escape the TFM string for regex

        Write-Output "Project roots to scan: $($projectRoots -join ', ')"
        Write-Output "Searching for TargetFramework '$tfmToReplace' (escaped: '$escapedTfmToReplace') to replace with '$tfmReplacement'."

        # Construct the regex pattern for <TargetFrameworks>...</TargetFrameworks>
        $regexPatternForTargetFrameworks = "([<TargetFrameworks>].*?;?)\s*$($escapedTfmToReplace)\s*(;?.*?<\TargetFrameworks>)"
        # Construct the regex pattern for <TargetFramework>...</TargetFramework>
        $regexPatternForTargetFramework = "<TargetFramework>$($escapedTfmToReplace)</TargetFramework>"
        $replacementForTargetFramework = "<TargetFramework>$($tfmReplacement)</TargetFramework>"

        Write-Output "Regex for <TargetFrameworks>: $regexPatternForTargetFrameworks"
        Write-Output "Regex for <TargetFramework>: $regexPatternForTargetFramework"
        
        foreach ($rootPath in $projectRoots) {
            if (Test-Path $rootPath) {
                Write-Output "Scanning directory: $rootPath"
                Get-ChildItem -Path $rootPath -Include *.csproj -Recurse | ForEach-Object {
                    $projectFile = $_.FullName
                    Write-Output "Processing project file: $projectFile"
                    $content = Get-Content $projectFile -Raw
                    $originalContent = $content 

                    # Check and replace within <TargetFrameworks>
                    if ($content -match "<TargetFrameworks>.*$($escapedTfmToReplace).*</TargetFrameworks>") {
                        Write-Output "Found '$tfmToReplace' in <TargetFrameworks> section of $($projectFile)."
                        $content = $content -replace $regexPatternForTargetFrameworks, ('$1' + $tfmReplacement + '$3')
                        
                        # Fallback if the more complex regex didn't change anything but the TFM is still present
                        if ($content -eq $originalContent -and $content -match $escapedTfmToReplace) {
                             Write-Output "Primary regex for <TargetFrameworks> didn't change content, trying simpler global replace for '$tfmToReplace' in this file..."
                             $content = $content -replace $escapedTfmToReplace, $tfmReplacement
                        }
                    }
                    # Else, check and replace within singular <TargetFramework>
                    elseif ($content -match $regexPatternForTargetFramework) {
                        Write-Output "Found '$tfmToReplace' in <TargetFramework> section of $($projectFile)."
                        $content = $content -replace $regexPatternForTargetFramework, $replacementForTargetFramework
                    }

                    if ($content -ne $originalContent) {
                        Set-Content -Path $projectFile -Value $content -Force -Encoding UTF8
                        Write-Output "Successfully updated TFM in $projectFile."
                    } else {
                        Write-Output "TFM '$tfmToReplace' not found or replacement logic didn't alter content in $projectFile."
                    }
                }
            } else {
                Write-Warning "Path $rootPath does not exist. Check checkout paths and calculated paths."
            }
        }
      shell: pwsh
      
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-tfmfix-${{ hashFiles('**/csproj') }}-${{ github.run_id }} 
        restore-keys: |
          ${{ runner.os }}-nuget-tfmfix-${{ hashFiles('**/csproj') }}-
          ${{ runner.os }}-nuget-tfmfix-
          ${{ runner.os }}-nuget-

    - name: List directory structure and verify TFM changes (for debugging)
      if: ${{ always() }}
      run: |
        Write-Output "GITHUB_WORKSPACE (from github context): ${{ github.workspace }}"
        Write-Output "GITHUB_WORKSPACE (from env context): $env:GITHUB_WORKSPACE"
        Write-Output "Workspace root structure (using $env:GITHUB_WORKSPACE):"
        Get-ChildItem -Path $env:GITHUB_WORKSPACE -Recurse -Depth 3 | Select-Object FullName
        Write-Output "Project files found (after potential modification):"
        
        $baseWorkspacePathForDebug = $env:GITHUB_WORKSPACE
        if ([string]::IsNullOrWhiteSpace($baseWorkspacePathForDebug)) { $baseWorkspacePathForDebug = "${{ github.workspace }}" }

        $projectRootsForDebug = @(
            (Join-Path $baseWorkspacePathForDebug "CSVGenerator"),
            (Join-Path $baseWorkspacePathForDebug "Common")
        )
        foreach ($rootPath in $projectRootsForDebug) {
            if (Test-Path $rootPath) {
                Get-ChildItem -Path $rootPath -Include *.csproj -Recurse | ForEach-Object {
                    Write-Output "--- Content of $($_.FullName) (first 25 lines) ---"
                    Get-Content $_.FullName | Select-Object -First 25
                    Write-Output "------------------------------------"
                }
            } else {
                 Write-Warning "Debug: Path $rootPath not found."
            }
        }
      
    - name: Build Common library for net48
      run: dotnet build (Join-Path $env:GITHUB_WORKSPACE "Common" "Common.csproj") -c Release -f net48

    - name: Build and Publish CSVGenerator for net48
      run: |
        dotnet publish (Join-Path $env:GITHUB_WORKSPACE "CSVGenerator" "CSVGenerator.csproj") `
          -r win-x64 `
          -f net48 `
          -c Release `
          -o (Join-Path $env:GITHUB_WORKSPACE "publish_output" "net48_win-x64")
      
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: CSVGenerator-net48-win-x64
        path: ${{ env.GITHUB_WORKSPACE }}/publish_output/net48_win-x64/
        if-no-files-found: error
