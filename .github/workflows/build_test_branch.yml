name: Test Build CSVGenerator

on:
  push:
    branches: [ test ]
  pull_request:
    branches: [ test ]
  workflow_dispatch:

jobs:
  build-and-publish:
    runs-on: windows-latest
    
    defaults:
      run:
        shell: pwsh

    steps:
    - name: Checkout CSVGenerator (this repository)
      uses: actions/checkout@v4
      with:
        path: CSVGenerator
        # 'ref' will default to the branch that triggered the workflow (e.g., 'test')

    - name: Checkout Common library
      uses: actions/checkout@v4
      with:
        repository: DarkPhilosophy/Common
        path: Common
        ref: test
        
    - name: Setup .NET SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x # We request 8.0.x, but runner might have newer (like 9.0.203)
                               # which is fine, but it's this newer SDK that errors on net10.0
        
    - name: Install .NET Framework 4.8 Developer Pack
      run: |
        choco install netfx-4.8-devpack -y --no-progress
        if ($LASTEXITCODE -ne 0) {
          Write-Error "Choco install failed for netfx-4.8-devpack"
          exit 1
        }

    - name: Temporarily update TargetFrameworks in project files for CI
      run: |
        $projectRoots = @(
            (Join-Path "${{ env.GITHUB_WORKSPACE }}" "CSVGenerator"),
            (Join-Path "${{ env.GITHUB_WORKSPACE }}" "Common")
        )
        $tfmToReplace = 'net10.0-windows'
        $tfmReplacement = 'net9.0-windows' # Ensure this matches an SDK the runner can handle

        Write-Output "Searching for TargetFramework '$tfmToReplace' to replace with '$tfmReplacement'."
        
        foreach ($rootPath in $projectRoots) {
            if (Test-Path $rootPath) {
                Get-ChildItem -Path $rootPath -Include *.csproj -Recurse | ForEach-Object {
                    $projectFile = $_.FullName
                    $content = Get-Content $projectFile -Raw
                    $originalContent = $content # Keep a copy for comparison

                    # Target the TFM within <TargetFrameworks>...</TargetFrameworks>
                    if ($content -match "<TargetFrameworks>.*$([regex]::Escape($tfmToReplace)).*</TargetFrameworks>") {
                        Write-Output "Updating TFM in $($projectFile) (within <TargetFrameworks>)..."
                        # This regex tries to replace the TFM and handle surrounding semicolons
                        $content = $content -replace "([<TargetFrameworks>].*?;?)\s*$([regex]::Escape($tfmToReplace))\s*(;?.*?<\TargetFrameworks>)", ('$1' + $tfmReplacement + '$3')
                        
                        # If the above didn't catch it (e.g., it was the only TFM without semicolons, or simple replace is safer)
                        if ($content -eq $originalContent -and $content -match [regex]::Escape($tfmToReplace)) {
                             Write-Output "Primary regex didn't change content for $projectFile, trying simpler replace..."
                             $content = $content -replace [regex]::Escape($tfmToReplace), $tfmReplacement
                        }
                    }
                    # Also handle if it's in a singular <TargetFramework> element
                    elseif ($content -match "<TargetFramework>$([regex]::Escape($tfmToReplace))</TargetFramework>") {
                        Write-Output "Updating TFM in $($projectFile) (within <TargetFramework>)..."
                        $content = $content -replace "<TargetFramework>$([regex]::Escape($tfmToReplace))</TargetFramework>", "<TargetFramework>$tfmReplacement</TargetFramework>"
                    }


                    if ($content -ne $originalContent) {
                        Set-Content -Path $projectFile -Value $content -Force -Encoding UTF8
                        Write-Output "Successfully updated TFM in $projectFile."
                    } else {
                        Write-Output "TFM '$tfmToReplace' not found or replacement logic didn't alter content in $projectFile."
                    }
                }
            } else {
                Write-Warning "Path $rootPath does not exist."
            }
        }
      shell: pwsh
      
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        # Add a component to the key that changes if the TFM replacement script logic changes, or use run_id if simpler
        key: ${{ runner.os }}-nuget-tfmfix-${{ hashFiles('**/csproj') }}-${{ github.run_id }} 
        restore-keys: |
          ${{ runner.os }}-nuget-tfmfix-${{ hashFiles('**/csproj') }}-
          ${{ runner.os }}-nuget-tfmfix-
          ${{ runner.os }}-nuget-

    - name: List directory structure and verify TFM changes (for debugging)
      if: ${{ always() }}
      run: |
        Write-Output "GITHUB_WORKSPACE: ${{ github.workspace }}"
        Write-Output "Workspace root structure (GITHUB_WORKSPACE):"
        Get-ChildItem -Path ${{ github.workspace }} -Recurse -Depth 3 | Select-Object FullName
        Write-Output "Project files found (after potential modification):"
        $projectRoots = @(
            (Join-Path "${{ github.workspace }}" "CSVGenerator"),
            (Join-Path "${{ github.workspace }}" "Common")
        )
        foreach ($rootPath in $projectRoots) {
            if (Test-Path $rootPath) {
                Get-ChildItem -Path $rootPath -Include *.csproj -Recurse | ForEach-Object {
                    Write-Output "--- Content of $($_.FullName) (first 25 lines) ---"
                    Get-Content $_.FullName | Select-Object -First 25
                    Write-Output "------------------------------------"
                }
            }
        }
      
    - name: Build Common library for net48
      # dotnet build will implicitly restore if needed for the specified framework
      run: dotnet build (Join-Path "${{ github.workspace }}" "Common" "Common.csproj") -c Release -f net48

    - name: Build and Publish CSVGenerator for net48
      # dotnet publish will implicitly restore and build if needed for the specified framework
      run: |
        dotnet publish (Join-Path "${{ github.workspace }}" "CSVGenerator" "CSVGenerator.csproj") `
          -r win-x64 `
          -f net48 `
          -c Release `
          -o (Join-Path "${{ github.workspace }}" "publish_output" "net48_win-x64")
      
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: CSVGenerator-net48-win-x64
        path: ${{ github.workspace }}/publish_output/net48_win-x64/
        if-no-files-found: error
