name: Test Build and Release CSVGenerator

on:
  push:
    branches: [ test ] 
  workflow_dispatch:

permissions:
  contents: write 

jobs:
  build-release: 
    runs-on: windows-latest
    
    defaults:
      run:
        shell: pwsh

    steps:
    - name: Checkout CSVGenerator (this repository)
      uses: actions/checkout@v4
      with:
        path: CSVGenerator
        fetch-depth: 0 

    - name: Checkout Common library
      uses: actions/checkout@v4
      with:
        repository: DarkPhilosophy/Common
        path: Common
        ref: test

    - name: Setup .NET SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x 
        
    - name: Install .NET Framework 4.8 Developer Pack
      run: |
        choco install netfx-4.8-devpack -y --no-progress
        if ($LASTEXITCODE -ne 0) {
          Write-Error "Choco install failed for netfx-4.8-devpack"
          exit 1
        }

    - name: Temporarily update TargetFrameworks in project files for CI
      env:
        CI_WORKSPACE: ${{ github.workspace }} 
      run: |
        # (TFM update script - assumed to be the last working version)
        Write-Output "Script starting. Value of CI_WORKSPACE from step env: '$($env:CI_WORKSPACE)'"
        Write-Output "Script starting. Value of GITHUB_WORKSPACE from direct env access: '$($env:GITHUB_WORKSPACE)'"
        $baseWorkspacePath = $env:GITHUB_WORKSPACE
        if ([string]::IsNullOrWhiteSpace($baseWorkspacePath)) {
            $baseWorkspacePath = $env:CI_WORKSPACE
        }
        if ([string]::IsNullOrWhiteSpace($baseWorkspacePath)) {
            Write-Error "Base workspace path is empty or null. Aborting."
            exit 1
        }
        $csvGeneratorCheckoutPath = Join-Path $baseWorkspacePath "CSVGenerator" 
        $commonCheckoutPath = Join-Path $baseWorkspacePath "Common"          
        $projectRoots = @( $csvGeneratorCheckoutPath, $commonCheckoutPath )
        $tfmToReplace = 'net10.0-windows'; $tfmReplacement = 'net9.0-windows'
        $escapedTfmToReplace = [regex]::Escape($tfmToReplace)
        foreach ($rootPath in $projectRoots) {
            if (Test-Path $rootPath) {
                Get-ChildItem -Path $rootPath -Include *.csproj -Recurse | ForEach-Object {
                    $projectFile = $_.FullName; 
                    $content = Get-Content $projectFile -Raw; $originalContent = $content; $wasModified = $false
                    if ($content.Contains($tfmToReplace)) {
                        $content = $content.Replace($tfmToReplace, $tfmReplacement)
                        if ($content -ne $originalContent) { $wasModified = $true }
                    }
                    if (-not $wasModified -and $content.Contains($tfmToReplace)) {
                        $regexPatternForTargetFrameworks = "([<TargetFrameworks>].*?;?)\s*$($escapedTfmToReplace)\s*(;?.*?<\TargetFrameworks>)"
                        if ($content -match "<TargetFrameworks>.*$($escapedTfmToReplace).*</TargetFrameworks>") {
                            $tempContent = $content -replace $regexPatternForTargetFrameworks, ('$1' + $tfmReplacement + '$3')
                            if ($tempContent -ne $content) { $content = $tempContent; $wasModified = $true;}
                        }
                        if (-not $wasModified -and $content -match "<TargetFramework>$($escapedTfmToReplace)</TargetFramework>") {
                             $regexPatternForTargetFramework = "<TargetFramework>$($escapedTfmToReplace)</TargetFramework>"
                             $replacementForTf = "<TargetFramework>$($tfmReplacement)</TargetFramework>"
                             $tempContent = $content -replace $regexPatternForTargetFramework, $replacementForTf
                             if ($tempContent -ne $content) { $content = $tempContent; $wasModified = $true;}
                        }
                    }
                    if ($wasModified) { Set-Content -Path $projectFile -Value $content -Force -Encoding UTF8; Write-Output "Updated $projectFile."}
                }
            }
        }

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-tfmfix-${{ hashFiles('**/csproj') }}-${{ github.run_id }} 
        restore-keys: |
          ${{ runner.os }}-nuget-tfmfix-${{ hashFiles('**/csproj') }}-
          ${{ runner.os }}-nuget-tfmfix-
          ${{ runner.os }}-nuget-
      
    - name: Build Common library for net48
      run: dotnet build (Join-Path $env:GITHUB_WORKSPACE "Common" "Common.csproj") -c Release -f net48

    - name: Publish CSVGenerator for net48
      id: publish-csvgenerator 
      run: |
        $publishDir = Join-Path $env:GITHUB_WORKSPACE "publish_output" "net48_win-x64"
        dotnet publish (Join-Path $env:GITHUB_WORKSPACE "CSVGenerator" "CSVGenerator.csproj") `
          -r win-x64 `
          -f net48 `
          -c Release `
          -o $publishDir
        Write-Output "CSVGenerator published to $publishDir"
        echo "publish_dir=$publishDir" >> $env:GITHUB_OUTPUT
        
    - name: Prepare Release Assets and Metadata
      id: release-prep 
      run: |
        $ErrorActionPreference = "Stop" 
        try {
            $publishDir = "${{ steps.publish-csvgenerator.outputs.publish_dir }}"
            Write-Output "INFO: Publish directory for asset prep: $publishDir"
            $stagingDir = Join-Path $env:GITHUB_WORKSPACE "release_staging" 
            $relativeStagingDir = "release_staging" 
            New-Item -ItemType Directory -Path $stagingDir -Force
            Write-Output "INFO: Staging directory ensured: $stagingDir"
            
            $exeFile = Get-ChildItem -Path $publishDir -Filter CSVGenerator.exe -ErrorAction SilentlyContinue | Select-Object -First 1
            
            if (-not $exeFile) {
                Write-Error "FATAL_ERROR: Main executable (CSVGenerator.exe) not found in $publishDir!"
                exit 1 
            }

            Write-Output "INFO: Found executable: $($exeFile.FullName)"
            Copy-Item -Path $exeFile.FullName -Destination $stagingDir -Force
            $stagedExePath = Join-Path $stagingDir $exeFile.Name
            Write-Output "INFO: Copied EXE to staging path: $stagedExePath"

            Write-Output "INFO: Getting version info..."
            $versionInfo = (Get-Item $stagedExePath).VersionInfo
            $fileVersion = $versionInfo.FileVersion
            if ([string]::IsNullOrWhiteSpace($fileVersion)) {
                $fileVersion = "0.0.0.1" 
            }
            $productVersion = $versionInfo.ProductVersion
            Write-Output "INFO: FileVersion: $fileVersion, ProductVersion: $productVersion"
            
            $sha256 = (Get-FileHash -Path $stagedExePath -Algorithm SHA256).Hash
            Write-Output "INFO: SHA256: $sha256"

            $buildTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC"
            Write-Output "INFO: BuildTime: $buildTime"
            
            $gitRepoPath = Join-Path $env:GITHUB_WORKSPACE "CSVGenerator"
            $commitHash = "GIT_UNAVAILABLE"
            $rawCommitMessage = "GIT_UNAVAILABLE"
            $latestTagName = $null

            if (Test-Path (Join-Path $gitRepoPath ".git")) {
                Push-Location $gitRepoPath
                try {
                    $commitHash = git rev-parse HEAD
                    $rawCommitMessage = (git log -1 --pretty=%B).Trim()
                    $latestTagName = $(git describe --tags --abbrev=0 2>$null)
                    if ([string]::IsNullOrWhiteSpace($latestTagName)) { $latestTagName = $null }
                } catch {
                    Write-Warning "WARN: Git operations failed. Error: $($_.Exception.Message)"
                } finally {
                    Pop-Location
                }
            } else {
                Write-Warning "WARN: Not a git repository at $gitRepoPath."
            }
            Write-Output "INFO: CommitHash: $commitHash"
            Write-Output "INFO: RawCommitMessage (first 60): $($rawCommitMessage.Substring(0, [System.Math]::Min($rawCommitMessage.Length, 60)))"
            Write-Output "INFO: LatestTagName: $latestTagName"

            $formattedCommitMessageLines = $rawCommitMessage -split '(\r?\n)' | ForEach-Object {
                if ($_ -match '\S') { $_.TrimEnd() + "  " } else { $_ }
            }
            $formattedCommitMessage = $formattedCommitMessageLines -join "`n"
            Write-Output "INFO: FormattedCommitMessage (first 60): $($formattedCommitMessage.Substring(0, [System.Math]::Min($formattedCommitMessage.Length, 60)))"

            Write-Output "INFO: Creating metadata content..."
            $metadataLines = @(
                "Product: CSVGenerator",
                "File: $($exeFile.Name)",
                "Version: $fileVersion",
                "ProductVersion: $productVersion",
                "Build Time: $buildTime",
                "Commit: $commitHash",
                "Commit Message (raw):"
            )
            $rawCommitMessage -split '(\r?\n)' | ForEach-Object { $metadataLines += $_.TrimEnd() }
            $metadataLines += "SHA256: $sha256"
            $metadataContent = $metadataLines -join [Environment]::NewLine
                            
            $metadataFilePath = Join-Path $stagingDir "$($exeFile.Name).metadata.txt"
            Set-Content -Path $metadataFilePath -Value $metadataContent
            Write-Output "INFO: Metadata written."

            # --- Construct Release Notes Body (Ultra Simplified String for _part2) ---
            Write-Output "DEBUG: Constructing Release Notes Body..."
            $_part1 = "- Commit: $($commitHash)" # Removed backticks for this test
            Write-Output "DEBUG: _part1 = '$_part1'"

            $simpleMessageString = "Message" # Ultra simple
            $_part2 = "- $simpleMessageString" # Ultra simple
            Write-Output "DEBUG: _part2 (ultra-simplified) = '$_part2'"
            
            $_commitMessageBlockContent = ""
            if (-not [string]::IsNullOrWhiteSpace($formattedCommitMessage)) {
                $_commitMessageBlockContent = ($formattedCommitMessage -split "`n" | ForEach-Object { 
                    if ($_.Trim().Length -gt 0) { "  > " + $_.TrimEnd(" ") } else { ""} 
                }) -join [Environment]::NewLine
                $_commitMessageBlockContent = $_commitMessageBlockContent.TrimEnd([Environment]::NewLine.ToCharArray())
            }
            
            $defaultReleaseNotesBody = $_part1 + [Environment]::NewLine + $_part2 + [Environment]::NewLine + $_commitMessageBlockContent
            $releaseNotesBody = $defaultReleaseNotesBody

            if ($latestTagName) { 
                Push-Location $gitRepoPath
                try {
                    $commitsSinceLastTag = git log "${latestTagName}..HEAD" --pretty=format:"- %s (`%h`)" --reverse | Where-Object { $_.Trim() }
                    if ($commitsSinceLastTag) {
                        $releaseNotesBody = "### Changes since ${latestTagName}" + [Environment]::NewLine + ($commitsSinceLastTag -join [Environment]::NewLine)
                    }
                } catch { Write-Warning "WARN: Failed getting commits since last tag. $($_.Exception.Message)" }
                finally { Pop-Location }
            }
            
            Write-Output "INFO: Final Release Notes Body (first 100 chars): $($releaseNotesBody.Substring(0, [System.Math]::Min($releaseNotesBody.Length, 100)) )"

            Write-Output "INFO: Creating release notes file content..."
            $releaseNotesLines = @(
                "# CSVGenerator v$fileVersion (Test Build)",
                "Build Date: $buildTime",
                "SHA256: $sha256 ($($exeFile.Name))",
                "", 
                "## Details / Changes"
            )
            $releaseNotesBody -split '(\r?\n)' | ForEach-Object { $releaseNotesLines += $_.TrimEnd() }
            $releaseNotesText = $releaseNotesLines -join [Environment]::NewLine
            
            $releaseNotesFilePath = Join-Path $stagingDir "release-notes.md" 
            $relativeReleaseNotesPath = Join-Path $relativeStagingDir "release-notes.md" 
            Set-Content -Path $releaseNotesFilePath -Value $releaseNotesText
            Write-Output "INFO: Release notes written."

            echo "version=$fileVersion" >> $env:GITHUB_OUTPUT
            echo "release_notes_path=$relativeReleaseNotesPath" >> $env:GITHUB_OUTPUT 
            echo "assets_path=$relativeStagingDir" >> $env:GITHUB_OUTPUT         
            
            Write-Output "INFO: Script completed. Exiting 0."
            exit 0 
        } catch {
            Write-Error "FATAL_ERROR: $($_.Exception.ToString()) Line: $($_.InvocationInfo.ScriptLineNumber)" 
            exit 1 
        }
      shell: pwsh
      
    - name: Upload Build Artifact (for debugging/retention)
      if: always() 
      uses: actions/upload-artifact@v4
      with:
        name: CSVGenerator-Build-Test-${{ steps.release-prep.outputs.version || github.run_number }}
        path: ${{ steps.publish-csvgenerator.outputs.publish_dir }}/ 
        if-no-files-found: warn 
        retention-days: 7
        
    - name: Create GitHub Release on 'test' branch
      if: github.event_name == 'push' && github.ref == 'refs/heads/test' 
      uses: softprops/action-gh-release@v2
      with:
        name: Test Release - CSVGenerator v${{ steps.release-prep.outputs.version }}
        tag_name: test-v${{ steps.release-prep.outputs.version }}-${{ github.run_id }} 
        body_path: ${{ steps.release-prep.outputs.release_notes_path }}
        files: |
          ${{ steps.release-prep.outputs.assets_path }}/CSVGenerator.exe
          ${{ steps.release-prep.outputs.assets_path }}/CSVGenerator.exe.metadata.txt
        draft: false
        prerelease: true 
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    # No final debug step
